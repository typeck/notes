### mysql 架构
连接线程处理 - 查询缓存、解析器 - 优化器 - 存储引擎

**事务**

事务的标准特征：ACID
1. 原子性（atomicity）
  一个事务必须被视为一个不可分割的最小单元，不可能只执行其中的一部分操作。
2. 一致性（consistency）
  数据库总是从一个一致性的状态转换到另一个一致性的状态。
3. 隔离性（isolation）
 一个事务所做的修改在最终提交以前，对其他事务时不可见的。
4. 持久性（durability）
   一旦事务提交，则其所做的修改就会永久保存到数据库中，即使系统现在崩溃。

**隔离级别**
* read uncmmitted（未提交读）
称为脏读。（很少使用）
* read committed（提交读）
大多数数据库默认的隔离级别（mysql除外）。一个事务开始时，只能看见已经提交的事务所作的修改。称为不可重复读。（两次读取的数不一样）
* repeatable read（可重复读）
解决了脏读的问题。保证了在同一个事务中多次读取同样的结果是一致的。无法解决幻读的问题。（MySQL默认）。（第一次读没有，第二次读就有）
* serializable （可串行化）
最高的隔离级别。强制事务串行处理，避免了幻读。在读取的每一行数据上都加锁。（很少用）

**事务日志**

使用事务日志，存储引擎在修改表时，只需要修改其内存拷贝，再把改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。写日志操作是磁盘顺序io，采用事务日志的方式会快的多。

**多版本并发控制（MVCC）**

InnoDb的MVCC，是通过每行记录后面保存两个隐藏的列来实现的。
这两个列一个保存了行的创建版本号，一个保存了行的过期版本号。每开始一个新的事务，版本号就会自动递增。事务开始时刻的版本号会做为事务的版本号。
* select
   * innodb只查找版本早于当前事务版本的数据行，可以确保事务读取的行，要么是在事务开始前存在的，要么是事务自身修改的。
   * 行的删除版本要么未定义，要么大于当前事务版本号。这样确保事务读取到的行，在事务开始前未被删除。
  
  （意思是选择在本事务开始前就存在的，并且在本事务后才删除的的记录）
* insert
innodb为新插入的每一行保存当前版本号，作为行版本号。
* delete
为删除的每一行保存当前版本号作为删除标志。
* update
为插入一行新纪录，保存当前版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标志。

保存这两个额外的版本号，使大多数读操作都可以不用加锁。
MVCC只在repeatable read和read commit两个隔离级别下工作。

[幻读详解1](https://blog.csdn.net/qq_33330687/article/details/89004462)
[幻读详解2](https://blog.csdn.net/qq_33330687/article/details/89004462)

innodb 采用mvcc来支持高并发，并是实现了四个标准的隔离级别。默认级别是可重复读，并通过间隙锁（next-key locking）策略防止幻读的出现。

### schema与数据类型优化
**优化数据类型**

1. 更小的通常好
2. 简单就好
3. 避免null

varchar适合存储字符串的最大长度比平均长度大很多；
在更新时，如果一个字符串过长，在页内没有足够的空间，则会产生碎片保存。
 char适合存储很短的字符串，或者所有值接近一个长度，比如密码md5。

blob和text都是为存储很大的数据而设计的字符串类型。分别采用二进制和字符方式存储。

使用枚举值（enum）代替字符串类型。

避免使用bit类型。

整数通常是标识列最好的选择，快且可以使用auto_increment。避免使用enum、set和字符串类型作为标识列。

对于随机的字符串md5、sha1、uuid等，这些函数生成的值会任意的分布在很大的空间内，会导致insert和select会很慢。

避免：

* 太多的列
* 太多的关联
* 过度使用枚举（单个查询最好在12个表以下）
* 避免使用null，可以使用特殊的字符代替空值。

范式的优缺点：

* 范式更新操作快
* 当数据较好的范式化后，就只有很少的重复数据，所以只需要修改更少的数据
* 范式化的表通常更小，可以更好的放在内存里，操作快
* 很少多余的数据意味着检索时更少需要distinct或者group by 语句。

缺点是通常需要关联。

### 创建高性能索引

索引，也叫做key，是存储引擎用于快速找到记录的一种数据结构。

在mysql中索引是在存储引擎中实现的，而不是服务器层。
存储引擎首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。

索引可以包含一个或对各列的值。如果索引包含多个列，那么列的顺序也十分重要，mysql只能高效的使用索引的最左列。

在mysql中索引是在存储引擎层而不是服务器层实现的。

**B-Tree索引**

B-Tree索引适用于全键值、键值范围、键前缀查找。

- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列（即第一列全匹配，第二列范围匹配）
- 只访问索引的查询

索引树中的节点是有序的，所以除了按值查找外，还可以用于查询中的order by操作。（如果b-tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序）。

限制：

  - 如果不是按照索引最左列查找，则无法使用。
  - 不能跳过索引中的列
  - 如果查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查找。（如果范围查询的列值的数量有限，可以通过使用多个等于条件来代替范围查询。

**哈希索引**

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。

对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希表将所有的哈希码存储在索引中，同时在哈希表中保持指向没改数据行的指针。

索引只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。

限制：

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值避免读取行。
- 哈希索引不是顺序的， 无法用于排序。
- 哈希索引不支持部分索引列的匹配查找。
- 哈希索引只支持等值的比较。不支持任何范围的查询。
- 访问哈希索引的数据非常快，除非有很多哈希冲突。
- 如果哈希冲突很多的话，一些索引维护的操作的代价也会很高
  
因为这些限制，哈希索引只适用于某些特定场合，一旦适合哈希索引，带来的提升十分显著。

innodb支持”自适应哈希索引“，当某些索引值被使用的非常频繁时，会在内存中基于b-tree索引之上再创建一个哈希索引。

创建自定义哈希索引

可以在b-tree上创建一个伪哈希索引。即在原来基础上增加一个哈希列作为索引：
```sql
select id from url where url= "http//xxxx.com"
-->
select id from url where url= "http//xxxx.com" and url_crc=CRC32("http//xxxx.com")
```
这样使用的缺陷是需要手动维护哈希值。可以手动维护，也可以触发器实现。
![img](img/捕获.PNG)

如果使用这种方式，不要使用sha1和md5作为哈希函数，因为这两个函数计算的哈希值非常长，强加密函数。

如果数据表非常大，可以自己实现64位哈希函数。

处理哈希冲突。当使用哈希索引时，必须在where中包含常量值。如果不是查询具体值（统计计数），可以不带入。

**索引的优点**

- 索引大大减少了服务器需要扫描的数据量
- 索引帮助服务器避免了排序和临时表
- 索引可以将随机io变为顺序io





