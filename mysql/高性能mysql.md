### mysql 架构
连接线程处理 - 查询缓存、解析器 - 优化器 - 存储引擎

**事务**

事务的标准特征：ACID
1. 原子性（atomicity）
  一个事务必须被视为一个不可分割的最小单元，不可能只执行其中的一部分操作。
2. 一致性（consistency）
  数据库总是从一个一致性的状态转换到另一个一致性的状态。
3. 隔离性（isolation）
 一个事务所做的修改在最终提交以前，对其他事务时不可见的。
4. 持久性（durability）
   一旦事务提交，则其所做的修改就会永久保存到数据库中，即使系统现在崩溃。

**隔离级别**
* read uncmmitted（未提交读）
称为脏读。（很少使用）
* read committed（提交读）
大多数数据库默认的隔离级别（mysql除外）。一个事务开始时，只能看见已经提交的事务所作的修改。称为不可重复读。（两次读取的数不一样）
* repeatable read（可重复读）
解决了脏读的问题。保证了在同一个事务中多次读取同样的结果是一致的。无法解决幻读的问题。（MySQL默认）。（第一次读没有，第二次读就有）
* serializable （可串行化）
最高的隔离级别。强制事务串行处理，避免了幻读。在读取的每一行数据上都加锁。（很少用）

**事务日志**

使用事务日志，存储引擎在修改表时，只需要修改其内存拷贝，再把改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到硬盘。写日志操作是磁盘顺序io，采用事务日志的方式会快的多。

**多版本并发控制（MVCC）**

InnoDb的MVCC，是通过每行记录后面保存两个隐藏的列来实现的。
这两个列一个保存了行的创建版本号，一个保存了行的过期版本号。每开始一个新的事务，版本号就会自动递增。事务开始时刻的版本号会做为事务的版本号。
* select
   * innodb只查找版本早于当前事务版本的数据行，可以确保事务读取的行，要么是在事务开始前存在的，要么是事务自身修改的。
   * 行的删除版本要么未定义，要么大于当前事务版本号。这样确保事务读取到的行，在事务开始前未被删除。
  
  （意思是选择在本事务开始前就存在的，并且在本事务后才删除的的记录）
* insert
innodb为新插入的每一行保存当前版本号，作为行版本号。
* delete
为删除的每一行保存当前版本号作为删除标志。
* update
为插入一行新纪录，保存当前版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标志。

保存这两个额外的版本号，使大多数读操作都可以不用加锁。
MVCC只在repeatable read和read commit两个隔离级别下工作。

[幻读详解1](https://blog.csdn.net/qq_33330687/article/details/89004462)
[幻读详解2](https://blog.csdn.net/qq_33330687/article/details/89004462)

innodb 采用mvcc来支持高并发，并是实现了四个标准的隔离级别。默认级别是可重复读，并通过间隙锁（next-key locking）策略防止幻读的出现。

### schema与数据类型优化
**优化数据类型**

1. 更小的通常好
2. 简单就好
3. 避免null

varchar适合存储字符串的最大长度比平均长度大很多；
在更新时，如果一个字符串过长，在页内没有足够的空间，则会产生碎片保存。
 char适合存储很短的字符串，或者所有值接近一个长度，比如密码md5。

blob和text都是为存储很大的数据而设计的字符串类型。分别采用二进制和字符方式存储。

使用枚举值（enum）代替字符串类型。

避免使用bit类型。

整数通常是标识列最好的选择，快且可以使用auto_increment。避免使用enum、set和字符串类型作为标识列。

对于随机的字符串md5、sha1、uuid等，这些函数生成的值会任意的分布在很大的空间内，会导致insert和select会很慢。

避免：

* 太多的列
* 太多的关联
* 过度使用枚举（单个查询最好在12个表以下）
* 避免使用null，可以使用特殊的字符代替空值。

范式的优缺点：

* 范式更新操作快
* 当数据较好的范式化后，就只有很少的重复数据，所以只需要修改更少的数据
* 范式化的表通常更小，可以更好的放在内存里，操作快
* 很少多余的数据意味着检索时更少需要distinct或者group by 语句。

缺点是通常需要关联。

### 创建高性能索引

索引，也叫做key，是存储引擎用于快速找到记录的一种数据结构。

在mysql中索引是在存储引擎中实现的，而不是服务器层。
存储引擎首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。

索引可以包含一个或对各列的值。



