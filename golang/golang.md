### 1，slice 底层实现
**Array**

在 Go 中，与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和函数传参操作都会复制整个数组数据。

**切片的数据结构**

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。

切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个与指向数组的动态窗口。

slice的数据结构：
```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```
Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。

手动构造一个slice：
```go
var ptr unsafe.Pointer
var s1 = struct {
    addr uintptr
    len int
    cap int
}{ptr, length, length}
s := *(*[]byte)(unsafe.Pointer(&s1))
```
make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制。

Go 中切片扩容的策略是这样的：

如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。

一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。

### golang内存模型
**进程**：进程是系统进行资源分配的基本单位，有独立的内存空间。

**线程**：线程是cpu调度和分派的最小单位，有独立的内存空间。

**协程**：协程是一种用户态的轻量级线程，协程的调度完全由用户控制，协程间的切换只需要保存任务的上下文，没有内核开销。
